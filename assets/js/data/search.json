[ { "title": "Deploying the Pokédex", "url": "/posts/deployment/", "categories": "projects", "tags": "ci-cd, web-dev", "date": "2022-03-10 21:21:00 +0000", "snippet": "Although I have worked, debugged, and tested my source code at my past internships, I have never actually participated in the process of shipping a software product. This is why I have decided to tackle part 11 of the full-stack web development series, in order to learn more about this surprisingly challenging concept. You can learn more here: https://fullstackopen.com/en/part11Branches and pull requestsThese two ideas are fundamental in the success of a software project with a developer team of size &amp;gt; 1. Because the main (or master) branch must be kept as polished and bug-free as possible, developers are expected to work on their own branches (to fix bugs, add a new feature, etc.) then create a pull request that needs to be approved by another human prior to the code changes to be integrated with the main branch.Github ActionsGitHub Actions is a service provided by GitHub that automates your development workflow, including building, testing, and deploying. GitHub Actions is triggered by GitHub events, such as a push to a certain branch (musually main), the opening of a pull request, and even a schedule that dictates when the build job is to occur. GitHub Actions executes your scripts, which are .yml or .yaml files in the .github/workflows directory, which has to be syntaxed properly. Here is one example of a build script that I used for the forked Pokédex repository:name: Deployment pipelineon: push: branches: - master pull_request: branches: [master] types: [opened, synchronize]jobs: simple_deployment_pipeline: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: actions/setup-node@v2 with: node-version: &#39;16&#39; - name: npm install run: npm install - name: lint run: npm run lint - name: build run: npm run build - name: test run: npm test - name: e2e tests uses: cypress-io/github-action@v2 with: command: npm run test:e2e start: npm run start-prod wait-on: http://localhost:5000 - name: deploy if: ${ { github.event_name == &#39;push&#39; } } uses: akhileshns/heroku-deploy@v3.12.12 with: heroku_api_key: ${ { secrets.HEROKU_API_KEY } } heroku_app_name: pokemon-fanatic heroku_email: &quot;&amp;lt;email goes here&amp;gt;&quot; healthcheck: &quot;https://&amp;lt;heroku url goes here&amp;gt;/health&quot; checkstring: &quot;ok&quot; rollbackonhealthcheckfailed: trueThis particular script is triggered by a push to the master branch, as well as the opening of a pull request from some other branch to master. When triggered, GitHub Actions executes a collection of tasks known as jobs. This script only has one job: simple_deployment_pipeline, but can have more.Please note that much like Python, yaml files depend on indents for proper execution.simple_deployment_pipeline consists of many steps, but first it needs to instantiate an operating system container. Here, it is the latest version of ubuntu. After an instance of ubuntu is created, this is what happens next: actions/checkout checks out the repository (if you do not perform this step, GitHub Actions won’t have any files to operate on!) actions/setup-node sets up node.js, version 16 npm install installs the dependencies listed under packages.json npm run lint runs the linter (the lint command must be configured in packages.json) npm run build builds the software npm test runs tests (here, Jest was testing React components) cypress-io/github-action executes end-to-end tests, or integration tests. The ubuntu instance will launch Cypress under port 5000, and then will carry out the tests in the cypress/ folder. (Note: I actually had some trouble with Cypress testing when I was using a GitHub Actions mocking library called act, so I commented it out. act is run locally on your computer as a Docker container, and is useful when your build script grows large, so that you can test that the script works before pushing it to GitHub.) heroku-deploy deploys your web application to Heroku, and if configured, also performs a health check by sending a GET request to /health. If the server responds with ok, then everything is fine; otherwise the software is rolled back to the previous version. You require a HEROKU_API_KEY that must be set in GitHub under the Secrets page in Settings, which is used to authenticate GitHub Actions to allow deployment. Also, note that the deploy step only occurs if the GitHub event that triggered this workflow was push (in other words, a pull request would not cause the app to deploy to Heroku.) ConclusionBy forking this Pokedéx repository and adding my own build scripts for GitHub Actions, I was able to learn several key aspects of the continuous integration / continuous deployment process. The GitHub Actions cloud compute is not particularly high spec: it only has two cores, 7GB RAM, and 14 GB of SSD space. 1 Therefore, running the entire pipeline can be time consuming, particularly when installing node_modules. While automating the process of building and testing the software is highly convenient, the developer must also build, lint, test, and deploy on their own machine to verify that each of these steps actually works. Though this particular build file was relatively simple (albeit with many steps), scripts can get complicated. This is why one should ideally use act (as mentioned earlier) or run the script on a dummy GitHub repository before pushing to the actual repo. You can see my forked Pokédex repository here!(By the way, my favorite Pokemon is Espeon.)Citations https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners &amp;#8617; " }, { "title": "Tic-Tac-Toe (and a baby bot)", "url": "/posts/tictactoe/", "categories": "projects", "tags": "artificial-intelligence", "date": "2022-03-10 21:21:00 +0000", "snippet": "I’ve actually started this project back in 2017, when I was still a novice programmer. When I was still a college student, I was told towork on personal projects in order to stand out and get precious internship experience. I had finished the command line version of this game back thenand was in the middle of developing a GUI version of the game using Qt, but I got bored with the project and quit halfway. Thus, my portfolio was simplya simple, unimpressive application and a half-baked Qt game that really should’ve been implemented using an actual game development framework, like Unity or even PyGame.I’ve recently looked back at this project this year, and thought, “Perhaps I could add artificial intelligence to the game.” So I went ahead and implemented the minimax algorithm for this game. Here is the pseudocode for the algorithm 1:def minimax(game, current_state): if game.over: return score(game) scores = [] # an array of scores, which are numbers moves = [] # an array of moves # Populate the scores array, recursing as needed moves = game.get_available_moves(current_state) for move in moves: possible_game = game.get_new_state(move) game.switch_turn() scores.push(minimax(game, possible_game)) moves.push(move) # Do the min or the max calculation if game.active_turn == player # player aims to maximize max_score = max(score) max_score_index = scores.index(max_score) choice = moves[max_score_index] # &amp;lt;- important! return scores[max_score_index] else # opponent aims to minimize min_score = min(score) min_score_index = scores.index(min_score) choice = moves[min_score_index] return scores[min_score_index]def score(game): if game.win(): return 10 # just an arbitrary value elif game.lose(): return -10 # same value, opposite sign else: return 0The minimax algorithm is a relatively simple one, compared to other algorithms such as A*, Dijkstra’s, or even machine learning and deep learning. (Part of the reason for my interest in implementing minimax was because I’ve been interested in AI and machine learning for years. I might pursue graduate school specializing in AI in the future, but for now I’ll pursue it as a hobby.)At a high level, minimax takes a game and its current state, and does two things. If the game is over (either a line of X or O, or a draw), it returns the score. It returns 10 if the AI wins, and -10 if the opponent wins (in other words, the player). It returns 0 if the AI and opponent tie. Otherwise, the algorithm expands the current state by considering all the possible moves. For example, if the current state looked like below and it is X’s turn to move:X’s turn to moveThen the list of possible moves is [(current state + (row1, column 3)), (current state + (row 2, column 1)), (current state + (row 2, column 2)), ...]For each of those new states, the minimax function is called on that new state. The turn is switch, hence it would be O’s turn. Since the minimax function ultimately returns a score (an integer), it pushes that value to the list of scores for that state, aptly called scores. After minimax is evaluated on that state, the move itself that results in that state is also pushed to a different list called moves.When scores and moves are completed, the function checks whether the active turn is the player (ie. the AI) or the opponent (ie. the human). Naturally, the player will want to perform a move that will maximize its score, since a high positive score is correlated with a win for the AI. Conversely, the opponent will want to perfrom a move that will minimize the score, since a high negative score is correlated with a win for the opponent. Thus, the function returns the highest score (or lowest) possible, given the current state of the game.It is also important to note that while minimax returns a number, it also returns choice, which is the move that will result in the max score possible given the current state. Since the caller of the initial minimax function (before recursions) will always be the AI, it will return the highest score possible. But more importantly, it will return the move that corresponds to the highest score. Since the function is (game, state) =&amp;gt; number, the optimal choice will have to be returned via some other method. In C++, one can use pointers to achieve this effect.Thank you for reading my first article! I hope to publish more content and projects in the future. The GitHub repository can be found here: https://github.com/luminouslily35/tictactoe/" } ]
